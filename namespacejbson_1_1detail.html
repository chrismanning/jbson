<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>jbson: jbson::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">jbson
   </div>
   <div id="projectbrief">C++11/1y BSON library</div>
  </td>
  <!-- github -->
  <a id="forkme_banner" href="https://github.com/chrismanning/jbson">View on GitHub</a>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejbson.html">jbson</a></li><li class="navelem"><a class="el" href="namespacejbson_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">jbson::detail Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>namespace detail contains internal functions and classes  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>container_has_push_back_impl</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1document__iter.html">document_iter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward traversal iterator type for traversing <a class="el" href="classjbson_1_1basic__document.html" title="BSON document. ">basic_document</a> and <a class="el" href="classjbson_1_1basic__array.html" title="BSON array. ">basic_array</a>.  <a href="structjbson_1_1detail_1_1document__iter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1elem__compare.html">elem_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> comparison.  <a href="structjbson_1_1detail_1_1elem__compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1element__visitor.html">element_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to implement <a class="el" href="structjbson_1_1basic__element.html#a4091e9a5cd74f1fbb57de5c62871b50d" title="Apply the visitor pattern with a void-return visitor. ">basic_element::visit</a> with <a class="el" href="namespacejbson_1_1detail.html#a5976eb2b32b45472fdc84d6edd24441d" title="void visit. ">detail::visit</a>.  <a href="structjbson_1_1detail_1_1element__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__constructible.html">is_constructible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__constructible_3_01A_00_01B_00_01std_1_1enable__if__t_3_01std_1_1is_63b014c4858eaa42af017d0de75825f6.html">is_constructible&lt; A, B, std::enable_if_t&lt; std::is_arithmetic&lt; std::decay_t&lt; A &gt; &gt;::value||std::is_arithmetic&lt; std::decay_t&lt; B &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__convertible.html">is_convertible</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__convertible_3_01A_00_01B_00_01std_1_1enable__if__t_3_01std_1_1is__i557bdbf3850eeafcdb8c50d59b7ae396.html">is_convertible&lt; A, B, std::enable_if_t&lt; std::is_integral&lt; std::decay_t&lt; A &gt; &gt;::value &amp;&amp;std::is_floating_point&lt; std::decay_t&lt; B &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__convertible_3_01A_00_01B_00_01std_1_1enable__if__t_3_01std_1_1is__ib50f2a7a2f21e26e4439d2399d3eef0e.html">is_convertible&lt; A, B, std::enable_if_t&lt; std::is_integral&lt; std::decay_t&lt; A &gt; &gt;::value &amp;&amp;std::is_integral&lt; std::decay_t&lt; B &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__convertible_3_01A_00_01B_00_01std_1_1enable__if__t_3_01std_1_1is__i6f62532dadce2137b7647b887096a580.html">is_convertible&lt; A, B, std::enable_if_t&lt; std::is_integral&lt; std::decay_t&lt; B &gt; &gt;::value &amp;&amp;std::is_floating_point&lt; std::decay_t&lt; A &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__document.html">is_document</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is a <a class="el" href="classjbson_1_1basic__document.html" title="BSON document. ">basic_document</a> (or <a class="el" href="classjbson_1_1basic__array.html" title="BSON array. ">basic_array</a>)  <a href="structjbson_1_1detail_1_1is__document.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__element.html">is_element</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is a <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a>.  <a href="structjbson_1_1detail_1_1is__element.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__iterator__pointer.html">is_iterator_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine if an iterator is a pointer, or pointer in disguise.  <a href="structjbson_1_1detail_1_1is__iterator__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__iterator__range.html">is_iterator_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine whether a type is a boost::iterator_range.  <a href="structjbson_1_1detail_1_1is__iterator__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__nothrow__swappable.html">is_nothrow_swappable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if a type is nothrow/noexcept swappable.  <a href="structjbson_1_1detail_1_1is__nothrow__swappable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1is__valid__func.html">is_valid_func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for type validity checking visitors.  <a href="structjbson_1_1detail_1_1is__valid__func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1make__string.html">make_string</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1make__string_3_01boost_1_1string__ref_01_4.html">make_string&lt; boost::string_ref &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1quote.html">quote</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic version of boost::mpl::quoteN.  <a href="structjbson_1_1detail_1_1quote.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1set__visitor.html">set_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1detail_1_1typeid__visitor.html">typeid_visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor for obtaining std::type_index of a mapped element_type.  <a href="structjbson_1_1detail_1_1typeid__visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time map. Maps element_types to C++ type for serialisation/deserialisation.  <a href="classjbson_1_1detail_1_1TypeMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adeae22e9b1d5c7fc9e3ea5f4be798915"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeae22e9b1d5c7fc9e3ea5f4be798915"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actual_element_type</b> = boost::error_info&lt; struct actual_element_type_, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;</td></tr>
<tr class="separator:adeae22e9b1d5c7fc9e3ea5f4be798915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ff2568c2c00c7b1381c0e9eff5cc97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4ff2568c2c00c7b1381c0e9eff5cc97"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actual_size</b> = boost::error_info&lt; struct actual_size_, ptrdiff_t &gt;</td></tr>
<tr class="separator:ad4ff2568c2c00c7b1381c0e9eff5cc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f958a9e450918c7ae5ce9f4805fa35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69f958a9e450918c7ae5ce9f4805fa35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>actual_type</b> = boost::error_info&lt; struct actual_type_, std::type_index &gt;</td></tr>
<tr class="separator:a69f958a9e450918c7ae5ce9f4805fa35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac267f03c904d80404e89585e9485d0ba"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ac267f03c904d80404e89585e9485d0ba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#ac267f03c904d80404e89585e9485d0ba">container_has_push_back</a> = typename mpl::eval_if&lt; has_iterator&lt; std::decay_t&lt; Container &gt;&gt;, container_has_push_back_impl&lt; std::decay_t&lt; Container &gt;&gt;, std::false_type &gt;::type</td></tr>
<tr class="memdesc:ac267f03c904d80404e89585e9485d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine if type is a container with a push_back() function.  <a href="#ac267f03c904d80404e89585e9485d0ba">More...</a><br /></td></tr>
<tr class="separator:ac267f03c904d80404e89585e9485d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753116341bca781589c1f721bc2d758b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a753116341bca781589c1f721bc2d758b"></a>
template&lt;element_type EType&gt; </td></tr>
<tr class="memitem:a753116341bca781589c1f721bc2d758b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a753116341bca781589c1f721bc2d758b">element_type_c</a> = std::integral_constant&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>, EType &gt;</td></tr>
<tr class="memdesc:a753116341bca781589c1f721bc2d758b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns an element_type into a boost::mpl constant. <br /></td></tr>
<tr class="separator:a753116341bca781589c1f721bc2d758b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44faf9fbb1cb4a16db909040b15a05f2"><td class="memTemplParams" colspan="2">template&lt;element_type EType, typename Container &gt; </td></tr>
<tr class="memitem:a44faf9fbb1cb4a16db909040b15a05f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2">ElementTypeMap</a> = typename mpl::at&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container &gt;::map_type, <a class="el" href="namespacejbson_1_1detail.html#a753116341bca781589c1f721bc2d758b">element_type_c</a>&lt; EType &gt;&gt;::type</td></tr>
<tr class="memdesc:a44faf9fbb1cb4a16db909040b15a05f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to perform boost::mpl::at on <a class="el" href="classjbson_1_1detail_1_1TypeMap.html#a7fabafd5e38a22c2132f46bba8fa8385" title="boost::mpl map. ">TypeMap::map_type</a>.  <a href="#a44faf9fbb1cb4a16db909040b15a05f2">More...</a><br /></td></tr>
<tr class="separator:a44faf9fbb1cb4a16db909040b15a05f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3af07e73bf2cf04ddebf7355547b42"><td class="memTemplParams" colspan="2">template&lt;element_type EType, typename Container &gt; </td></tr>
<tr class="memitem:aed3af07e73bf2cf04ddebf7355547b42"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">ElementTypeMapSet</a> = typename mpl::at&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container, true &gt;::map_type, <a class="el" href="namespacejbson_1_1detail.html#a753116341bca781589c1f721bc2d758b">element_type_c</a>&lt; EType &gt;&gt;::type</td></tr>
<tr class="memdesc:aed3af07e73bf2cf04ddebf7355547b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to perform boost::mpl::at on <a class="el" href="classjbson_1_1detail_1_1TypeMap.html#a7fabafd5e38a22c2132f46bba8fa8385" title="boost::mpl map. ">TypeMap::map_type</a>.  <a href="#aed3af07e73bf2cf04ddebf7355547b42">More...</a><br /></td></tr>
<tr class="separator:aed3af07e73bf2cf04ddebf7355547b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94d95ff24644ab4ca4508b7d4051a1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac94d95ff24644ab4ca4508b7d4051a1c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>expected_element_type</b> = boost::error_info&lt; struct expected_element_type_, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;</td></tr>
<tr class="separator:ac94d95ff24644ab4ca4508b7d4051a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9890298817b4aa45f41b62e2d0cd20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b9890298817b4aa45f41b62e2d0cd20"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>expected_size</b> = boost::error_info&lt; struct expected_size_, ptrdiff_t &gt;</td></tr>
<tr class="separator:a8b9890298817b4aa45f41b62e2d0cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e993f0ef42081d19553bddb3978af2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a92e993f0ef42081d19553bddb3978af2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>expected_type</b> = boost::error_info&lt; struct expected_type_, std::type_index &gt;</td></tr>
<tr class="separator:a92e993f0ef42081d19553bddb3978af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf84949b9c1ed4bf8ab8b2c3587f1382"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf84949b9c1ed4bf8ab8b2c3587f1382"></a>
template&lt;typename MapT , typename FunT &gt; </td></tr>
<tr class="memitem:adf84949b9c1ed4bf8ab8b2c3587f1382"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_if_second</b> = typename mpl::find_if&lt; MapT, mpl::bind&lt; mpl::protect&lt; FunT &gt;, mpl::bind&lt; mpl::quote1&lt; mpl::second &gt;, mpl::_1 &gt;&gt;&gt;::type</td></tr>
<tr class="separator:adf84949b9c1ed4bf8ab8b2c3587f1382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdaffa46dcd62f2de127a1773b2f9dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7bdaffa46dcd62f2de127a1773b2f9dd"></a>
template&lt;typename MapT , typename T &gt; </td></tr>
<tr class="memitem:a7bdaffa46dcd62f2de127a1773b2f9dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find_second</b> = typename mpl::find_if&lt; MapT, mpl::bind&lt; <a class="el" href="structjbson_1_1detail_1_1quote.html">quote</a>&lt; std::is_same &gt;, T, mpl::bind&lt; mpl::quote1&lt; mpl::second &gt;, mpl::_1 &gt;&gt;&gt;::type</td></tr>
<tr class="separator:a7bdaffa46dcd62f2de127a1773b2f9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f549807c214863e29778cc65b242f7"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename ElementTrait , typename RangeTrait &gt; </td></tr>
<tr class="memitem:ab4f549807c214863e29778cc65b242f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">is_range_of</a> = typename mpl::apply&lt; typename mpl::eval_if&lt; is_range&lt; RangeT &gt;, mpl::identity&lt; ElementTrait &gt;, mpl::identity&lt; mpl::always&lt; mpl::false_ &gt;&gt;&gt;::type, typename mpl::eval_if&lt; is_range&lt; RangeT &gt;, mpl::apply&lt; RangeTrait, std::decay_t&lt; RangeT &gt;&gt;, mpl::identity&lt; void &gt;&gt;::type &gt;::type</td></tr>
<tr class="memdesc:ab4f549807c214863e29778cc65b242f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to apply a unary metafunction to the result of a Range trait in a SFINAE safe manner.  <a href="#ab4f549807c214863e29778cc65b242f7">More...</a><br /></td></tr>
<tr class="separator:ab4f549807c214863e29778cc65b242f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c208a65c530ee691e2b684238acc6"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename ElementTrait &gt; </td></tr>
<tr class="memitem:ae71c208a65c530ee691e2b684238acc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#ae71c208a65c530ee691e2b684238acc6">is_range_of_iterator</a> = <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">is_range_of</a>&lt; RangeT, ElementTrait, mpl::quote1&lt; boost::range_mutable_iterator &gt;&gt;</td></tr>
<tr class="memdesc:ae71c208a65c530ee691e2b684238acc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to apply a unary metafunction trait to the iterator type of a Range.  <a href="#ae71c208a65c530ee691e2b684238acc6">More...</a><br /></td></tr>
<tr class="separator:ae71c208a65c530ee691e2b684238acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d75904aea03cbbe1707c04dd3fd110"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename ElementT &gt; </td></tr>
<tr class="memitem:a50d75904aea03cbbe1707c04dd3fd110"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">is_range_of_same_value</a> = <a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4">is_range_of_value</a>&lt; RangeT, mpl::bind2&lt; mpl::quote2&lt; std::is_same &gt;, ElementT, mpl::_1 &gt;&gt;</td></tr>
<tr class="memdesc:a50d75904aea03cbbe1707c04dd3fd110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to determine equivalence of the value_type of a Range.  <a href="#a50d75904aea03cbbe1707c04dd3fd110">More...</a><br /></td></tr>
<tr class="separator:a50d75904aea03cbbe1707c04dd3fd110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69e70904ca6d48e0df89bf40ef5a6d4"><td class="memTemplParams" colspan="2">template&lt;typename RangeT , typename ElementTrait &gt; </td></tr>
<tr class="memitem:ae69e70904ca6d48e0df89bf40ef5a6d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4">is_range_of_value</a> = <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">is_range_of</a>&lt; RangeT, ElementTrait, mpl::quote1&lt; boost::range_value &gt;&gt;</td></tr>
<tr class="memdesc:ae69e70904ca6d48e0df89bf40ef5a6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to apply a unary metafunction trait to the value_type of a Range.  <a href="#ae69e70904ca6d48e0df89bf40ef5a6d4">More...</a><br /></td></tr>
<tr class="separator:ae69e70904ca6d48e0df89bf40ef5a6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25536ea99406679dac1ed1b995591d8c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25536ea99406679dac1ed1b995591d8c"></a>
template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:a25536ea99406679dac1ed1b995591d8c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_valid_element_set_type</b> = typename mpl::not_&lt; std::is_same&lt; typename mpl::end&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container, true &gt;::map_type &gt;::type, find_if_second&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container, true &gt;::map_type, mpl::bind&lt; <a class="el" href="structjbson_1_1detail_1_1quote.html">quote</a>&lt; <a class="el" href="structjbson_1_1detail_1_1is__constructible.html">is_constructible</a> &gt;, mpl::_1, T &gt;&gt;&gt;&gt;::type</td></tr>
<tr class="separator:a25536ea99406679dac1ed1b995591d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af875b8c66b23d2b6be448f9276b7712e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af875b8c66b23d2b6be448f9276b7712e"></a>
template&lt;typename Container , typename T &gt; </td></tr>
<tr class="memitem:af875b8c66b23d2b6be448f9276b7712e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_valid_element_value_type</b> = typename mpl::not_&lt; std::is_same&lt; typename mpl::end&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container &gt;::map_type &gt;::type, find_if_second&lt; typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt; Container &gt;::map_type, mpl::bind&lt; <a class="el" href="structjbson_1_1detail_1_1quote.html">quote</a>&lt; <a class="el" href="structjbson_1_1detail_1_1is__convertible.html">is_convertible</a> &gt;, T, mpl::_1 &gt;&gt;&gt;&gt;::type</td></tr>
<tr class="separator:af875b8c66b23d2b6be448f9276b7712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adde086624df9f653cded1f18f21ebf07"><td class="memTemplParams" colspan="2"><a class="anchor" id="adde086624df9f653cded1f18f21ebf07"></a>
template&lt;typename RangeT , typename ArithT &gt; </td></tr>
<tr class="memitem:adde086624df9f653cded1f18f21ebf07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, ArithT &amp;num, std::enable_if_t&lt; std::is_arithmetic&lt; ArithT &gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:adde086624df9f653cded1f18f21ebf07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef18c2fe01965493fe554bbbd6b2671"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6ef18c2fe01965493fe554bbbd6b2671"></a>
template&lt;typename RangeT , typename StringT &gt; </td></tr>
<tr class="memitem:a6ef18c2fe01965493fe554bbbd6b2671"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, StringT &amp;str, std::enable_if_t&lt; std::is_convertible&lt; std::decay_t&lt; StringT &gt;, boost::string_ref &gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:a6ef18c2fe01965493fe554bbbd6b2671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd64a485fda7d5f529394ede162dac2e"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd64a485fda7d5f529394ede162dac2e"></a>
template&lt;typename RangeT , typename Container , typename EContainer &gt; </td></tr>
<tr class="memitem:acd64a485fda7d5f529394ede162dac2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, <a class="el" href="classjbson_1_1basic__document.html">basic_document</a>&lt; Container, EContainer &gt; &amp;doc)</td></tr>
<tr class="separator:acd64a485fda7d5f529394ede162dac2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8ef2765a5175eebbaf665ac7573cd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f8ef2765a5175eebbaf665ac7573cd6"></a>
template&lt;typename RangeT , typename Container , typename EContainer &gt; </td></tr>
<tr class="memitem:a0f8ef2765a5175eebbaf665ac7573cd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, <a class="el" href="classjbson_1_1basic__array.html">basic_array</a>&lt; Container, EContainer &gt; &amp;arr)</td></tr>
<tr class="separator:a0f8ef2765a5175eebbaf665ac7573cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a0f2bd73fb42df41e4980d43d52fb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a45a0f2bd73fb42df41e4980d43d52fb7"></a>
template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a45a0f2bd73fb42df41e4980d43d52fb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, std::vector&lt; char &gt; &amp;vec)</td></tr>
<tr class="separator:a45a0f2bd73fb42df41e4980d43d52fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358fc33af26ec5384da4e323e1905a57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a358fc33af26ec5384da4e323e1905a57"></a>
template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a358fc33af26ec5384da4e323e1905a57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, RangeT &amp;vec)</td></tr>
<tr class="separator:a358fc33af26ec5384da4e323e1905a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c2d3c592d81f907581c838e09c15b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76c2d3c592d81f907581c838e09c15b6"></a>
template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a76c2d3c592d81f907581c838e09c15b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, std::array&lt; char, 12 &gt; &amp;oid)</td></tr>
<tr class="separator:a76c2d3c592d81f907581c838e09c15b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c34684b2d90f5325fed80feeca032"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1a9c34684b2d90f5325fed80feeca032"></a>
template&lt;typename RangeT , typename StringT &gt; </td></tr>
<tr class="memitem:a1a9c34684b2d90f5325fed80feeca032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, std::tuple&lt; StringT, StringT &gt; &amp;tuple, std::enable_if_t&lt; std::is_constructible&lt; std::string, std::decay_t&lt; StringT &gt;&gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:a1a9c34684b2d90f5325fed80feeca032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d57c50ad016693f62bc6664ad2a0d09"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d57c50ad016693f62bc6664ad2a0d09"></a>
template&lt;typename RangeT , typename StringT &gt; </td></tr>
<tr class="memitem:a0d57c50ad016693f62bc6664ad2a0d09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, std::tuple&lt; StringT, std::array&lt; char, 12 &gt;&gt; &amp;tuple, std::enable_if_t&lt; std::is_constructible&lt; std::string, std::decay_t&lt; StringT &gt;&gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:a0d57c50ad016693f62bc6664ad2a0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a2b5671188bd2e419ead29b8a42dc5"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5a2b5671188bd2e419ead29b8a42dc5"></a>
template&lt;typename RangeT , typename StringT , typename DocContainerT , typename DocEContainerT &gt; </td></tr>
<tr class="memitem:aa5a2b5671188bd2e419ead29b8a42dc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialise</b> (const RangeT &amp;data, std::tuple&lt; StringT, <a class="el" href="classjbson_1_1basic__document.html">basic_document</a>&lt; DocContainerT, DocEContainerT &gt;&gt; &amp;tuple, std::enable_if_t&lt; std::is_constructible&lt; std::string, std::decay_t&lt; StringT &gt;&gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:aa5a2b5671188bd2e419ead29b8a42dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4a54e48d382e245e7a1ccaae785e4e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b4a54e48d382e245e7a1ccaae785e4e"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4b4a54e48d382e245e7a1ccaae785e4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a4b4a54e48d382e245e7a1ccaae785e4e">init_empty</a> (Container &amp;c)</td></tr>
<tr class="memdesc:a4b4a54e48d382e245e7a1ccaae785e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises a container or range for a valid empty <a class="el" href="classjbson_1_1basic__document.html" title="BSON document. ">basic_document</a> or <a class="el" href="classjbson_1_1basic__array.html" title="BSON array. ">basic_array</a>. <br /></td></tr>
<tr class="separator:a4b4a54e48d382e245e7a1ccaae785e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c7e6896834d8c1073b7542f4f745e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0c7e6896834d8c1073b7542f4f745e7"></a>
template&lt;typename T , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ab0c7e6896834d8c1073b7542f4f745e7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>little_endian_to_native</b> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr class="separator:ab0c7e6896834d8c1073b7542f4f745e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e791366dee0590ab1e049d2b001a58"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71e791366dee0590ab1e049d2b001a58"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71e791366dee0590ab1e049d2b001a58"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; char, sizeof(T)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>native_to_little_endian</b> (T val)</td></tr>
<tr class="separator:a71e791366dee0590ab1e049d2b001a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99620465ee04ec36955e03cdbfa40d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="af99620465ee04ec36955e03cdbfa40d7"></a>
template&lt;typename Container , typename IteratorT , typename T &gt; </td></tr>
<tr class="memitem:af99620465ee04ec36955e03cdbfa40d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, T val, std::enable_if_t&lt; std::is_arithmetic&lt; T &gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:af99620465ee04ec36955e03cdbfa40d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef0a146a615f70e6dadb22087c3777"><td class="memTemplParams" colspan="2"><a class="anchor" id="abbef0a146a615f70e6dadb22087c3777"></a>
template&lt;typename Container , typename IteratorT &gt; </td></tr>
<tr class="memitem:abbef0a146a615f70e6dadb22087c3777"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, boost::string_ref val)</td></tr>
<tr class="separator:abbef0a146a615f70e6dadb22087c3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1734e676880d4bf7ea8381d8122c5e52"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1734e676880d4bf7ea8381d8122c5e52"></a>
template&lt;typename Container , typename IteratorT , typename DocContainer , typename DocEContainer &gt; </td></tr>
<tr class="memitem:a1734e676880d4bf7ea8381d8122c5e52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, const <a class="el" href="classjbson_1_1basic__document.html">basic_document</a>&lt; DocContainer, DocEContainer &gt; &amp;val)</td></tr>
<tr class="separator:a1734e676880d4bf7ea8381d8122c5e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c67eca13f038b03546472947aef68a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c67eca13f038b03546472947aef68a4"></a>
template&lt;typename Container , typename IteratorT , typename DocContainer , typename DocEContainer &gt; </td></tr>
<tr class="memitem:a5c67eca13f038b03546472947aef68a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, const <a class="el" href="classjbson_1_1basic__array.html">basic_array</a>&lt; DocContainer, DocEContainer &gt; &amp;val)</td></tr>
<tr class="separator:a5c67eca13f038b03546472947aef68a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c282d46ca284fbc319d1673a0d9d52d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c282d46ca284fbc319d1673a0d9d52d"></a>
template&lt;typename Container , typename IteratorT &gt; </td></tr>
<tr class="memitem:a1c282d46ca284fbc319d1673a0d9d52d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, const std::array&lt; char, 12 &gt; &amp;val)</td></tr>
<tr class="separator:a1c282d46ca284fbc319d1673a0d9d52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e73f9c39ccb590b9474a78bbbf7336"><td class="memTemplParams" colspan="2"><a class="anchor" id="a74e73f9c39ccb590b9474a78bbbf7336"></a>
template&lt;typename Container , typename IteratorT , typename StringT &gt; </td></tr>
<tr class="memitem:a74e73f9c39ccb590b9474a78bbbf7336"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, const std::tuple&lt; StringT, StringT &gt; &amp;val, std::enable_if_t&lt; std::is_convertible&lt; StringT, boost::string_ref &gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:a74e73f9c39ccb590b9474a78bbbf7336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541617b1f6799c10603ed30aee6dbaa6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a541617b1f6799c10603ed30aee6dbaa6"></a>
template&lt;typename Container , typename IteratorT , typename StringT &gt; </td></tr>
<tr class="memitem:a541617b1f6799c10603ed30aee6dbaa6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;c, IteratorT &amp;it, const std::tuple&lt; StringT, std::array&lt; char, 12 &gt;&gt; &amp;val)</td></tr>
<tr class="separator:a541617b1f6799c10603ed30aee6dbaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6da6639a57bf6ef8462148678766aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa6da6639a57bf6ef8462148678766aa"></a>
template&lt;typename Container , typename IteratorT , typename StringT , typename DocContainer , typename DocEContainer &gt; </td></tr>
<tr class="memitem:aaa6da6639a57bf6ef8462148678766aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialise</b> (Container &amp;, IteratorT &amp;, const std::tuple&lt; StringT, <a class="el" href="classjbson_1_1basic__document.html">basic_document</a>&lt; DocContainer, DocEContainer &gt;&gt; &amp;, std::enable_if_t&lt; std::is_convertible&lt; StringT, boost::string_ref &gt;::value &gt; *=nullptr)</td></tr>
<tr class="separator:aaa6da6639a57bf6ef8462148678766aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad696780b2d13546da9055045cabb718d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad696780b2d13546da9055045cabb718d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>valid_type</b> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> etype)</td></tr>
<tr class="separator:ad696780b2d13546da9055045cabb718d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5976eb2b32b45472fdc84d6edd24441d"><td class="memTemplParams" colspan="2">template&lt;template&lt; element_type EType, typename...VArgs &gt; class Visitor, typename... Args&gt; </td></tr>
<tr class="memitem:a5976eb2b32b45472fdc84d6edd24441d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_void<br class="typebreak" />
&lt; decltype(std::declval<br class="typebreak" />
&lt; Visitor<br class="typebreak" />
&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, <br class="typebreak" />
Args...&gt;&gt;()(std::declval&lt; Args &amp;&amp; &gt;<br class="typebreak" />
)...))&gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a5976eb2b32b45472fdc84d6edd24441d">visit</a> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> type, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5976eb2b32b45472fdc84d6edd24441d"><td class="mdescLeft">&#160;</td><td class="mdescRight">void visit.  <a href="#a5976eb2b32b45472fdc84d6edd24441d">More...</a><br /></td></tr>
<tr class="separator:a5976eb2b32b45472fdc84d6edd24441d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791a5788dd5f45712d88101563428087"><td class="memTemplParams" colspan="2">template&lt;template&lt; element_type EType, typename...VArgs &gt; class Visitor, typename... Args&gt; </td></tr>
<tr class="memitem:a791a5788dd5f45712d88101563428087"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_void<br class="typebreak" />
&lt; decltype(std::declval<br class="typebreak" />
&lt; Visitor<br class="typebreak" />
&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, <br class="typebreak" />
Args...&gt;&gt;()(std::declval&lt; Args &amp;&amp; &gt;<br class="typebreak" />
)...))&gt;::value, decltype(std::declval<br class="typebreak" />
&lt; Visitor<br class="typebreak" />
&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, <br class="typebreak" />
Args...&gt;&gt;()(std::declval&lt; Args &amp;&amp; &gt;)...))&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacejbson_1_1detail.html#a791a5788dd5f45712d88101563428087">visit</a> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> type, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a791a5788dd5f45712d88101563428087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-void visit.  <a href="#a791a5788dd5f45712d88101563428087">More...</a><br /></td></tr>
<tr class="separator:a791a5788dd5f45712d88101563428087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace detail contains internal functions and classes </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac267f03c904d80404e89585e9485d0ba"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#ac267f03c904d80404e89585e9485d0ba">jbson::detail::container_has_push_back</a> = typedef typename mpl::eval_if&lt;has_iterator&lt;std::decay_t&lt;Container&gt;&gt;, container_has_push_back_impl&lt;std::decay_t&lt;Container&gt;&gt;, std::false_type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine if type is a container with a push_back() function. </p>
<p>Evaluates to std::false_type for all incompatible types (SFINAE friendly).</p>
<dl class="section see"><dt>See also</dt><dd>has_iterator has_const_iterator </dd></dl>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00183">183</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44faf9fbb1cb4a16db909040b15a05f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;element_type EType, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2">jbson::detail::ElementTypeMap</a> = typedef typename mpl::at&lt;typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt;Container&gt;::map_type, <a class="el" href="namespacejbson_1_1detail.html#a753116341bca781589c1f721bc2d758b">element_type_c</a>&lt;EType&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias to perform boost::mpl::at on <a class="el" href="classjbson_1_1detail_1_1TypeMap.html#a7fabafd5e38a22c2132f46bba8fa8385" title="boost::mpl map. ">TypeMap::map_type</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">TypeMap</a> <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">ElementTypeMapSet</a> </dd></dl>
<p>Maps an element_type to a type for deserialisation. </p>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00137">137</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aed3af07e73bf2cf04ddebf7355547b42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;element_type EType, typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">jbson::detail::ElementTypeMapSet</a> = typedef typename mpl::at&lt;typename <a class="el" href="classjbson_1_1detail_1_1TypeMap.html">TypeMap</a>&lt;Container, true&gt;::map_type, <a class="el" href="namespacejbson_1_1detail.html#a753116341bca781589c1f721bc2d758b">element_type_c</a>&lt;EType&gt;&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias to perform boost::mpl::at on <a class="el" href="classjbson_1_1detail_1_1TypeMap.html#a7fabafd5e38a22c2132f46bba8fa8385" title="boost::mpl map. ">TypeMap::map_type</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">TypeMap</a> <a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">ElementTypeMap</a> </dd></dl>
<p>Same as ElementTypeMap, but for serialising types rather than deserialising. </p>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00146">146</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4f549807c214863e29778cc65b242f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename ElementTrait , typename RangeTrait &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">jbson::detail::is_range_of</a> = typedef typename mpl::apply&lt; typename mpl::eval_if&lt;is_range&lt;RangeT&gt;, mpl::identity&lt;ElementTrait&gt;, mpl::identity&lt;mpl::always&lt;mpl::false_&gt;&gt;&gt;::type, typename mpl::eval_if&lt;is_range&lt;RangeT&gt;, mpl::apply&lt;RangeTrait, std::decay_t&lt;RangeT&gt;&gt;, mpl::identity&lt;void&gt;&gt;::type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to apply a unary metafunction to the result of a Range trait in a SFINAE safe manner. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4" title="Type trait to apply a unary metafunction trait to the value_type of a Range. ">is_range_of_value</a> <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110" title="Type trait to determine equivalence of the value_type of a Range. ">is_range_of_same_value</a> <a class="el" href="namespacejbson_1_1detail.html#ae71c208a65c530ee691e2b684238acc6" title="Type trait to apply a unary metafunction trait to the iterator type of a Range. ">is_range_of_iterator</a> </dd></dl>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00198">198</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae71c208a65c530ee691e2b684238acc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename ElementTrait &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#ae71c208a65c530ee691e2b684238acc6">jbson::detail::is_range_of_iterator</a> = typedef <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">is_range_of</a>&lt;RangeT, ElementTrait, mpl::quote1&lt;boost::range_mutable_iterator&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to apply a unary metafunction trait to the iterator type of a Range. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110" title="Type trait to determine equivalence of the value_type of a Range. ">is_range_of_same_value</a> <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7" title="Type trait to apply a unary metafunction to the result of a Range trait in a SFINAE safe manner...">is_range_of</a> </dd></dl>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00219">219</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a50d75904aea03cbbe1707c04dd3fd110"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename ElementT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">jbson::detail::is_range_of_same_value</a> = typedef <a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4">is_range_of_value</a>&lt;RangeT, mpl::bind2&lt;mpl::quote2&lt;std::is_same&gt;, ElementT, mpl::_1&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to determine equivalence of the value_type of a Range. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4" title="Type trait to apply a unary metafunction trait to the value_type of a Range. ">is_range_of_value</a> <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7" title="Type trait to apply a unary metafunction to the result of a Range trait in a SFINAE safe manner...">is_range_of</a> </dd></dl>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00212">212</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae69e70904ca6d48e0df89bf40ef5a6d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeT , typename ElementTrait &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacejbson_1_1detail.html#ae69e70904ca6d48e0df89bf40ef5a6d4">jbson::detail::is_range_of_value</a> = typedef <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7">is_range_of</a>&lt;RangeT, ElementTrait, mpl::quote1&lt;boost::range_value&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type trait to apply a unary metafunction trait to the value_type of a Range. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110" title="Type trait to determine equivalence of the value_type of a Range. ">is_range_of_same_value</a> <a class="el" href="namespacejbson_1_1detail.html#ab4f549807c214863e29778cc65b242f7" title="Type trait to apply a unary metafunction to the result of a Range trait in a SFINAE safe manner...">is_range_of</a> </dd></dl>

<p>Definition at line <a class="el" href="traits_8hpp_source.html#l00205">205</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5976eb2b32b45472fdc84d6edd24441d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; element_type EType, typename...VArgs &gt; class Visitor, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_void&lt; decltype(std::declval&lt;Visitor&lt;<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, Args...&gt;&gt;()(std::declval&lt;Args&amp;&amp;&gt;)...))&gt;::value&gt; jbson::detail::visit </td>
          <td>(</td>
          <td class="paramtype">element_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>void visit. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>type</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="visit_8hpp_source.html#l00024">24</a> of file <a class="el" href="visit_8hpp_source.html">visit.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a791a5788dd5f45712d88101563428087"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; element_type EType, typename...VArgs &gt; class Visitor, typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_void&lt;decltype( std::declval&lt;Visitor&lt;<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, Args...&gt;&gt;()(std::declval&lt;Args&amp;&amp;&gt;)...))&gt;::value, decltype(std::declval&lt;Visitor&lt;<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a6c90bbc96dde98161387fe51967a31ec">element_type::int64_element</a>, Args...&gt;&gt;()(std::declval&lt;Args&amp;&amp;&gt;)...))&gt; jbson::detail::visit </td>
          <td>(</td>
          <td class="paramtype">element_type&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-void visit. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>type</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="visit_8hpp_source.html#l00120">120</a> of file <a class="el" href="visit_8hpp_source.html">visit.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    Copyright &copy; 2014 <a href="http://www.chrismanning.me.uk/">Christian Manning</a>. </br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
