<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>jbson: jbson::basic_element&lt; Container &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">jbson
   </div>
   <div id="projectbrief">C++11/1y BSON library</div>
  </td>
  <!-- github -->
  <a id="forkme_banner" href="https://github.com/chrismanning/jbson">View on GitHub</a>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejbson.html">jbson</a></li><li class="navelem"><a class="el" href="structjbson_1_1basic__element.html">basic_element</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structjbson_1_1basic__element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">jbson::basic_element&lt; Container &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>BSON element.  
 <a href="structjbson_1_1basic__element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="element_8hpp_source.html">element.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aad57154ad9e7f7137e1be376ed2e76c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad57154ad9e7f7137e1be376ed2e76c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> = std::decay_t&lt; Container &gt;</td></tr>
<tr class="memdesc:aad57154ad9e7f7137e1be376ed2e76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying storage container. <br /></td></tr>
<tr class="separator:aad57154ad9e7f7137e1be376ed2e76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19e37f423945c887e784d5a630ff5942"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a19e37f423945c887e784d5a630ff5942">basic_element</a> ()=default</td></tr>
<tr class="memdesc:a19e37f423945c887e784d5a630ff5942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a19e37f423945c887e784d5a630ff5942">More...</a><br /></td></tr>
<tr class="separator:a19e37f423945c887e784d5a630ff5942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a4fd4e707e5b58634af47e703c84e8"><td class="memTemplParams" colspan="2">template&lt;typename OtherContainer &gt; </td></tr>
<tr class="memitem:a56a4fd4e707e5b58634af47e703c84e8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a56a4fd4e707e5b58634af47e703c84e8">basic_element</a> (const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;, std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:a56a4fd4e707e5b58634af47e703c84e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a56a4fd4e707e5b58634af47e703c84e8">More...</a><br /></td></tr>
<tr class="separator:a56a4fd4e707e5b58634af47e703c84e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9180d9811c12c002b4160d7942f0d30e"><td class="memTemplParams" colspan="2">template&lt;typename OtherContainer &gt; </td></tr>
<tr class="memitem:a9180d9811c12c002b4160d7942f0d30e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a9180d9811c12c002b4160d7942f0d30e">basic_element</a> (const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;, std::enable_if_t&lt;!std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr, std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, typename OtherContainer::const_iterator, typename OtherContainer::const_iterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:a9180d9811c12c002b4160d7942f0d30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a9180d9811c12c002b4160d7942f0d30e">More...</a><br /></td></tr>
<tr class="separator:a9180d9811c12c002b4160d7942f0d30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0953b6e3784c3f94a18dc0e823f06aa9"><td class="memTemplParams" colspan="2">template&lt;typename OtherContainer &gt; </td></tr>
<tr class="memitem:a0953b6e3784c3f94a18dc0e823f06aa9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a0953b6e3784c3f94a18dc0e823f06aa9">basic_element</a> (<a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;&amp;, std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &amp;&amp; &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:a0953b6e3784c3f94a18dc0e823f06aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a0953b6e3784c3f94a18dc0e823f06aa9">More...</a><br /></td></tr>
<tr class="separator:a0953b6e3784c3f94a18dc0e823f06aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065d2db4261167e2bc7cd0e54a1f403"><td class="memTemplParams" colspan="2">template&lt;typename ForwardRange &gt; </td></tr>
<tr class="memitem:ab065d2db4261167e2bc7cd0e54a1f403"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ab065d2db4261167e2bc7cd0e54a1f403">basic_element</a> (ForwardRange &amp;&amp;, std::enable_if_t&lt;!std::is_constructible&lt; std::string, ForwardRange &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr, std::enable_if_t&lt; <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">detail::is_range_of_same_value</a>&lt; ForwardRange, typename Container::value_type &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:ab065d2db4261167e2bc7cd0e54a1f403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element from raw BSON byte sequence.  <a href="#ab065d2db4261167e2bc7cd0e54a1f403">More...</a><br /></td></tr>
<tr class="separator:ab065d2db4261167e2bc7cd0e54a1f403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad402b7850426ce97ca327dc7a76b2979"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:ad402b7850426ce97ca327dc7a76b2979"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ad402b7850426ce97ca327dc7a76b2979">basic_element</a> (ForwardIterator &amp;&amp;first, ForwardIterator &amp;&amp;last, std::enable_if_t&lt; !std::is_constructible&lt; boost::string_ref, ForwardIterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>||std::is_convertible&lt; ForwardIterator, typename container_type::const_iterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr, std::enable_if_t&lt; <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">detail::is_range_of_same_value</a>&lt; decltype(boost::make_iterator_range(first, last)), typename Container::value_type &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:ad402b7850426ce97ca327dc7a76b2979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element from raw BSON byte sequence.  <a href="#ad402b7850426ce97ca327dc7a76b2979">More...</a><br /></td></tr>
<tr class="separator:ad402b7850426ce97ca327dc7a76b2979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf74444886ac85639ba9a07d494827a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf74444886ac85639ba9a07d494827a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#aaf74444886ac85639ba9a07d494827a2">basic_element</a> (std::string <a class="el" href="structjbson_1_1basic__element.html#ac87cf620131675bc9c53d49184b04505">name</a>, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> <a class="el" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>, T &amp;&amp;val)</td></tr>
<tr class="memdesc:aaf74444886ac85639ba9a07d494827a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element with specified name, type and value.  <a href="#aaf74444886ac85639ba9a07d494827a2">More...</a><br /></td></tr>
<tr class="separator:aaf74444886ac85639ba9a07d494827a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd3a1211bac1e7d043c1c22960d019"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4fdd3a1211bac1e7d043c1c22960d019"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a4fdd3a1211bac1e7d043c1c22960d019">basic_element</a> (std::string, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>, ForwardIterator, ForwardIterator)</td></tr>
<tr class="memdesc:a4fdd3a1211bac1e7d043c1c22960d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element with specified name, type and value data.  <a href="#a4fdd3a1211bac1e7d043c1c22960d019">More...</a><br /></td></tr>
<tr class="separator:a4fdd3a1211bac1e7d043c1c22960d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823d935d664b4326057cf2ef890517d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a823d935d664b4326057cf2ef890517d9">basic_element</a> (std::string, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>=<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a7858b91fc88a79e5da4003e432566bda">element_type::null_element</a>)</td></tr>
<tr class="memdesc:a823d935d664b4326057cf2ef890517d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element with specified name, and optionally, type.  <a href="#a823d935d664b4326057cf2ef890517d9">More...</a><br /></td></tr>
<tr class="separator:a823d935d664b4326057cf2ef890517d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcfc8074c83aff20f60ce6ba72854972"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcfc8074c83aff20f60ce6ba72854972"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#adcfc8074c83aff20f60ce6ba72854972">basic_element</a> (std::string <a class="el" href="structjbson_1_1basic__element.html#ac87cf620131675bc9c53d49184b04505">name</a>, T &amp;&amp;val)</td></tr>
<tr class="memdesc:adcfc8074c83aff20f60ce6ba72854972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an element with specified name and value.  <a href="#adcfc8074c83aff20f60ce6ba72854972">More...</a><br /></td></tr>
<tr class="separator:adcfc8074c83aff20f60ce6ba72854972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87cf620131675bc9c53d49184b04505"><td class="memItemLeft" align="right" valign="top">boost::string_ref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ac87cf620131675bc9c53d49184b04505">name</a> () const noexcept(std::is_nothrow_constructible&lt; boost::string_ref, const std::string &amp; &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>)</td></tr>
<tr class="memdesc:ac87cf620131675bc9c53d49184b04505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns name of element.  <a href="#ac87cf620131675bc9c53d49184b04505">More...</a><br /></td></tr>
<tr class="separator:ac87cf620131675bc9c53d49184b04505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738d7ca664acd205dbb3ba79acc4a8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ab738d7ca664acd205dbb3ba79acc4a8a">name</a> (std::string n)</td></tr>
<tr class="memdesc:ab738d7ca664acd205dbb3ba79acc4a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets name to n.  <a href="#ab738d7ca664acd205dbb3ba79acc4a8a">More...</a><br /></td></tr>
<tr class="separator:ab738d7ca664acd205dbb3ba79acc4a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162117fa843cf9c774ad9050c2712277"><td class="memTemplParams" colspan="2">template&lt;typename OutContainer &gt; </td></tr>
<tr class="memitem:a162117fa843cf9c774ad9050c2712277"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a162117fa843cf9c774ad9050c2712277">operator OutContainer</a> () const </td></tr>
<tr class="separator:a162117fa843cf9c774ad9050c2712277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9026fa681748cdb569063dbf592ecd4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9026fa681748cdb569063dbf592ecd4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a9026fa681748cdb569063dbf592ecd4c">operator!=</a> (const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a> &amp;other) const </td></tr>
<tr class="memdesc:a9026fa681748cdb569063dbf592ecd4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this and <code>other</code> are not equal. <br /></td></tr>
<tr class="separator:a9026fa681748cdb569063dbf592ecd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06054201aa8ae0413389eb0ac2400f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ad06054201aa8ae0413389eb0ac2400f9">operator&lt;</a> (const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a> &amp;other) const </td></tr>
<tr class="memdesc:ad06054201aa8ae0413389eb0ac2400f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this is less than (&lt;) <code>other</code>.  <a href="#ad06054201aa8ae0413389eb0ac2400f9">More...</a><br /></td></tr>
<tr class="separator:ad06054201aa8ae0413389eb0ac2400f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610052c4d9b6775f723ac4a762df77b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610052c4d9b6775f723ac4a762df77b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a610052c4d9b6775f723ac4a762df77b1">operator==</a> (const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a> &amp;other) const </td></tr>
<tr class="memdesc:a610052c4d9b6775f723ac4a762df77b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this and <code>other</code> are equal. <br /></td></tr>
<tr class="separator:a610052c4d9b6775f723ac4a762df77b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fabda76b4f9d50b889117dd69c5d95c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fabda76b4f9d50b889117dd69c5d95c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a6fabda76b4f9d50b889117dd69c5d95c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a6fabda76b4f9d50b889117dd69c5d95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns size in bytes. <br /></td></tr>
<tr class="separator:a6fabda76b4f9d50b889117dd69c5d95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b998131908c6cf65194404a241eac99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b998131908c6cf65194404a241eac99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a8b998131908c6cf65194404a241eac99">swap</a> (<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a8b998131908c6cf65194404a241eac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps contents with <code>other</code>. <br /></td></tr>
<tr class="separator:a8b998131908c6cf65194404a241eac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8bbd80da1d125661d9e3bb11d83f8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f8bbd80da1d125661d9e3bb11d83f8d"></a>
<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a> () const noexcept</td></tr>
<tr class="memdesc:a9f8bbd80da1d125661d9e3bb11d83f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns BSON type of this element. <br /></td></tr>
<tr class="separator:a9f8bbd80da1d125661d9e3bb11d83f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7208635bba6b45d2628d8cb6a19f67d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a7208635bba6b45d2628d8cb6a19f67d1">type</a> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> new_type)</td></tr>
<tr class="memdesc:a7208635bba6b45d2628d8cb6a19f67d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets type of this element.  <a href="#a7208635bba6b45d2628d8cb6a19f67d1">More...</a><br /></td></tr>
<tr class="separator:a7208635bba6b45d2628d8cb6a19f67d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7fbb5d707f751fbc2db5ac5a8ca41f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada7fbb5d707f751fbc2db5ac5a8ca41f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak" />
&lt; detail::is_valid_element_value_type<br class="typebreak" />
&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value, <br class="typebreak" />
T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> () const </td></tr>
<tr class="memdesc:ada7fbb5d707f751fbc2db5ac5a8ca41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value data in the form of a specific type.  <a href="#ada7fbb5d707f751fbc2db5ac5a8ca41f">More...</a><br /></td></tr>
<tr class="separator:ada7fbb5d707f751fbc2db5ac5a8ca41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959e42636ff0f847cf8e26bf2a079bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3959e42636ff0f847cf8e26bf2a079bb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak" />
&lt;!detail::is_valid_element_value_type<br class="typebreak" />
&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value, <br class="typebreak" />
T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a3959e42636ff0f847cf8e26bf2a079bb">value</a> () const </td></tr>
<tr class="memdesc:a3959e42636ff0f847cf8e26bf2a079bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value data in the form of a specific type.  <a href="#a3959e42636ff0f847cf8e26bf2a079bb">More...</a><br /></td></tr>
<tr class="separator:a3959e42636ff0f847cf8e26bf2a079bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acd85d63ec845dfde47a8149ee025a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4acd85d63ec845dfde47a8149ee025a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a4acd85d63ec845dfde47a8149ee025a6">value</a> (T &amp;&amp;val, std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:a4acd85d63ec845dfde47a8149ee025a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value from a <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a> compatible type.  <a href="#a4acd85d63ec845dfde47a8149ee025a6">More...</a><br /></td></tr>
<tr class="separator:a4acd85d63ec845dfde47a8149ee025a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01844fe37dd9d3903035a9e87a2cbcd0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01844fe37dd9d3903035a9e87a2cbcd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a01844fe37dd9d3903035a9e87a2cbcd0">value</a> (T &amp;&amp;val, std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:a01844fe37dd9d3903035a9e87a2cbcd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value from a user-defined type.  <a href="#a01844fe37dd9d3903035a9e87a2cbcd0">More...</a><br /></td></tr>
<tr class="separator:a01844fe37dd9d3903035a9e87a2cbcd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d320e825fdf95ab8184fb412821480"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2d320e825fdf95ab8184fb412821480"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ae2d320e825fdf95ab8184fb412821480">value</a> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> new_type, T &amp;&amp;val, std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:ae2d320e825fdf95ab8184fb412821480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element_type, and value from a <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a> compatible type.  <a href="#ae2d320e825fdf95ab8184fb412821480">More...</a><br /></td></tr>
<tr class="separator:ae2d320e825fdf95ab8184fb412821480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d40b400778dfdc44dc4aedab75461a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5d40b400778dfdc44dc4aedab75461a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ad5d40b400778dfdc44dc4aedab75461a">value</a> (<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> new_type, T &amp;&amp;val, std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:ad5d40b400778dfdc44dc4aedab75461a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element_type, and value from a user-defined type.  <a href="#ad5d40b400778dfdc44dc4aedab75461a">More...</a><br /></td></tr>
<tr class="separator:ad5d40b400778dfdc44dc4aedab75461a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae6f793662cfcec1643708cbf394a40"><td class="memTemplParams" colspan="2">template&lt;element_type EType, typename T &gt; </td></tr>
<tr class="memitem:acae6f793662cfcec1643708cbf394a40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#acae6f793662cfcec1643708cbf394a40">value</a> (T &amp;&amp;val, std::enable_if_t&lt; std::is_same&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">detail::ElementTypeMapSet</a>&lt; EType, <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &gt;&gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:acae6f793662cfcec1643708cbf394a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value. Statically ensures type compatibility.  <a href="#acae6f793662cfcec1643708cbf394a40">More...</a><br /></td></tr>
<tr class="separator:acae6f793662cfcec1643708cbf394a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cd66241d3ee9b62bf85078e4e531e3"><td class="memTemplParams" colspan="2">template&lt;element_type EType, typename T &gt; </td></tr>
<tr class="memitem:ac4cd66241d3ee9b62bf85078e4e531e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ac4cd66241d3ee9b62bf85078e4e531e3">value</a> (T &amp;&amp;val, std::enable_if_t&lt;!std::is_same&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">detail::ElementTypeMapSet</a>&lt; EType, <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &gt;&gt;::value &gt; *=nullptr)</td></tr>
<tr class="memdesc:ac4cd66241d3ee9b62bf85078e4e531e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets value. Statically ensures type compatibility.  <a href="#ac4cd66241d3ee9b62bf85078e4e531e3">More...</a><br /></td></tr>
<tr class="separator:ac4cd66241d3ee9b62bf85078e4e531e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4091e9a5cd74f1fbb57de5c62871b50d"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:a4091e9a5cd74f1fbb57de5c62871b50d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a4091e9a5cd74f1fbb57de5c62871b50d">visit</a> (Visitor &amp;&amp;, std::enable_if_t&lt; std::is_void&lt; decltype(std::declval&lt; Visitor &gt;()(&quot;&quot;, std::declval&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;(), std::declval&lt; double &gt;()))&gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr) const </td></tr>
<tr class="memdesc:a4091e9a5cd74f1fbb57de5c62871b50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the visitor pattern with a void-return visitor.  <a href="#a4091e9a5cd74f1fbb57de5c62871b50d">More...</a><br /></td></tr>
<tr class="separator:a4091e9a5cd74f1fbb57de5c62871b50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85de427b8084ac05d0a357ee26dd03b"><td class="memTemplParams" colspan="2">template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:af85de427b8084ac05d0a357ee26dd03b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#af85de427b8084ac05d0a357ee26dd03b">visit</a> (Visitor &amp;&amp;, std::enable_if_t&lt;!std::is_void&lt; decltype(std::declval&lt; Visitor &gt;()(&quot;&quot;, std::declval&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;(), std::declval&lt; double &gt;()))&gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr) const -&gt; decltype(std::declval&lt; Visitor &gt;()(&quot;&quot;, std::declval&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;(), std::declval&lt; double &gt;()))</td></tr>
<tr class="memdesc:af85de427b8084ac05d0a357ee26dd03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the visitor pattern with a value-returning visitor.  <a href="#af85de427b8084ac05d0a357ee26dd03b">More...</a><br /></td></tr>
<tr class="separator:af85de427b8084ac05d0a357ee26dd03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8025af3a29be37dc5c45da8c8d0762"><td class="memTemplParams" colspan="2">template&lt;typename OutContainer &gt; </td></tr>
<tr class="memitem:aad8025af3a29be37dc5c45da8c8d0762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#aad8025af3a29be37dc5c45da8c8d0762">write_to_container</a> (OutContainer &amp;, typename OutContainer::const_iterator) const </td></tr>
<tr class="memdesc:aad8025af3a29be37dc5c45da8c8d0762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> to BSON data.  <a href="#aad8025af3a29be37dc5c45da8c8d0762">More...</a><br /></td></tr>
<tr class="separator:aad8025af3a29be37dc5c45da8c8d0762"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abb12e9d7291e3135117ec26b18fbaec7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#abb12e9d7291e3135117ec26b18fbaec7">write_to_container</a> (<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;, typename container_type::const_iterator, boost::string_ref, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>)</td></tr>
<tr class="memdesc:abb12e9d7291e3135117ec26b18fbaec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a BSON element without data, in-place into a container.  <a href="#abb12e9d7291e3135117ec26b18fbaec7">More...</a><br /></td></tr>
<tr class="separator:abb12e9d7291e3135117ec26b18fbaec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6f6a9947ab08a6dc4ca4e3ab66096e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada6f6a9947ab08a6dc4ca4e3ab66096e"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#ada6f6a9947ab08a6dc4ca4e3ab66096e">write_to_container</a> (<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;, typename container_type::const_iterator, boost::string_ref, T &amp;&amp;)</td></tr>
<tr class="memdesc:ada6f6a9947ab08a6dc4ca4e3ab66096e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a type-deduced BSON element in-place into a container.  <a href="#ada6f6a9947ab08a6dc4ca4e3ab66096e">More...</a><br /></td></tr>
<tr class="separator:ada6f6a9947ab08a6dc4ca4e3ab66096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2633712f48994f2c326995cc4d500c38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2633712f48994f2c326995cc4d500c38"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#a2633712f48994f2c326995cc4d500c38">write_to_container</a> (<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;, typename container_type::const_iterator, boost::string_ref, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>, T &amp;&amp;, std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:a2633712f48994f2c326995cc4d500c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a BSON element in-place, from compatible data, into a container.  <a href="#a2633712f48994f2c326995cc4d500c38">More...</a><br /></td></tr>
<tr class="separator:a2633712f48994f2c326995cc4d500c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa573c7536e077d35d32743da19923037"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa573c7536e077d35d32743da19923037"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structjbson_1_1basic__element.html#aa573c7536e077d35d32743da19923037">write_to_container</a> (<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;, typename container_type::const_iterator, boost::string_ref, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>, T &amp;&amp;, std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *=nullptr)</td></tr>
<tr class="memdesc:aa573c7536e077d35d32743da19923037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a BSON element in-place, from incompatible data, into a container.  <a href="#aa573c7536e077d35d32743da19923037">More...</a><br /></td></tr>
<tr class="separator:aa573c7536e077d35d32743da19923037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa8c6ef07d820a5c3a238347e6e927e87"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8c6ef07d820a5c3a238347e6e927e87"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:aa8c6ef07d820a5c3a238347e6e927e87"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>basic_element</b></td></tr>
<tr class="separator:aa8c6ef07d820a5c3a238347e6e927e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Container&gt;<br />
struct jbson::basic_element&lt; Container &gt;</h3>

<p>BSON element. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>Type of the underlying data storage. Must be range of <code>char</code>. Must be detectably noexcept swappable. </td></tr>
  </table>
  </dd>
</dl>
<p>Currently stores the name and type separately from the value data. This is to simplify the implementation and the exception safety of it.</p>
<p>However, should the storage be unified it would eliminate std::string copies for all non-data-owning elements. It would also change the semantics to be more reasonable. Modifying the name of an element does not change the name in the underlying storage, and should thus be disallowed. The only way to enforce this is by using const basic_elements everywhere, or perhaps some tricky metaprogramming, or unified storage. </p>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00069">69</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19e37f423945c887e784d5a630ff5942"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Resultant <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> represents a valid, empty-named, <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a7858b91fc88a79e5da4003e432566bda" title="void ">element_type::null_element</a> typed BSON element. </p>

</div>
</div>
<a class="anchor" id="a56a4fd4e707e5b58634af47e703c84e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename OtherContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copies the contents of a <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> with a compatible container_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Element to be copied. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00678">678</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9180d9811c12c002b4160d7942f0d30e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename OtherContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, typename OtherContainer::const_iterator, typename OtherContainer::const_iterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Copies the contents of a <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> with an incompatible container_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Element to be copied. </td></tr>
  </table>
  </dd>
</dl>
<p>Does this via <code>container_type(begin(other), end(other))</code>. </p>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00689">689</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0953b6e3784c3f94a18dc0e823f06aa9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename OtherContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; OtherContainer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_constructible&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, OtherContainer &amp;&amp; &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Moves the contents of a <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> with a compatible container_type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Element to be moved. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00702">702</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab065d2db4261167e2bc7cd0e54a1f403"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardRange &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">ForwardRange &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_constructible&lt; std::string, ForwardRange &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">detail::is_range_of_same_value</a>&lt; ForwardRange, typename Container::value_type &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element from raw BSON byte sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Range of bytes representing BSON data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When range is too small. When value data is indicated to be larger than range. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When the detected element_type is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00715">715</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad402b7850426ce97ca327dc7a76b2979"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator &amp;&amp;&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; !std::is_constructible&lt; boost::string_ref, ForwardIterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>||std::is_convertible&lt; ForwardIterator, typename container_type::const_iterator &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; <a class="el" href="namespacejbson_1_1detail.html#a50d75904aea03cbbe1707c04dd3fd110">detail::is_range_of_same_value</a>&lt; decltype(boost::make_iterator_range(first, last)), typename Container::value_type &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element from raw BSON byte sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>Iterator to beginning of data. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past end of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When range is too small. When value data is indicated to be larger than range. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When the detected element_type is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00118">118</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf74444886ac85639ba9a07d494827a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element with specified name, type and value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When supplied type is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When type is value-less, e.g. null_element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00132">132</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4fdd3a1211bac1e7d043c1c22960d019"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an element with specified name, type and value data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the element. </td></tr>
    <tr><td class="paramname">type</td><td>Type of element the supplied data represents. </td></tr>
    <tr><td class="paramname">first</td><td>Iterator to start of data. </td></tr>
    <tr><td class="paramname">last</td><td>Iterator past the end of data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This constructor bypasses any type checking of the data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When the supplied element_type is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00747">747</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a823d935d664b4326057cf2ef890517d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a7858b91fc88a79e5da4003e432566bda">element_type::null_element</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element with specified name, and optionally, type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Element name. </td></tr>
    <tr><td class="paramname">type</td><td>Element type. Defaults to <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a7858b91fc88a79e5da4003e432566bda" title="void ">element_type::null_element</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When the supplied element_type is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00759">759</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adcfc8074c83aff20f60ce6ba72854972"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::<a class="el" href="structjbson_1_1basic__element.html">basic_element</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an element with specified name and value. </p>
<p>Attempts type deduction to determine suitable element_type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Element name. </td></tr>
    <tr><td class="paramname">val</td><td>JSON compatible value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When type deduction fails. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00151">151</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac87cf620131675bc9c53d49184b04505"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::string_ref <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns name of element. </p>
<dl class="section return"><dt>Returns</dt><dd>boost::string_ref. The <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> must remain alive at least as long as the returned string. </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00160">160</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab738d7ca664acd205dbb3ba79acc4a8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::name </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets name to n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Name to set element to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee (parameter <code>n</code> construction could throw). </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00170">170</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a162117fa843cf9c774ad9050c2712277"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename OutContainer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::operator OutContainer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Explicit conversion to a write_to_container compatible container. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structjbson_1_1basic__element.html#abb12e9d7291e3135117ec26b18fbaec7" title="Constructs a BSON element without data, in-place into a container. ">write_to_container</a> </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00666">666</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad06054201aa8ae0413389eb0ac2400f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structjbson_1_1basic__element.html">basic_element</a>&lt; Container &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this is less than (&lt;) <code>other</code>. </p>
<p>When the elements have differing types, simply compares names.</p>
<p>Only when both the types and names are equal are the values compared.<br />
When the values are <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a759e806af1addfe29a0752ed6c561673" title="std::string or boost::string_ref (string_type) ">element_type::string_element</a>, they are fetched and then compared according to the current global locale.<br />
When the values are <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a60b474ffad15db137619cf967efaff57" title="double ">element_type::double_element</a>, they are fetched and compared with <code>&lt;</code>.<br />
For all other types, a lexicographical comparison of the data is performed. </p>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00475">475</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7208635bba6b45d2628d8cb6a19f67d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>new_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets type of this element. </p>
<dl class="section note"><dt>Note</dt><dd>No checks are performed determining if the current value data is compatible with the new type.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_type</td><td>Valid BSON element_type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When type is invalid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00188">188</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada7fbb5d707f751fbc2db5ac5a8ca41f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;detail::is_valid_element_value_type&lt;<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T&gt;::value, T&gt; <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value data in the form of a specific type. </p>
<dl class="section note"><dt>Note</dt><dd>This overload only returns types from <a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMap</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type to be returned. Must be default constructible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value represented by this <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> in the form of a <code>T</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When <code>ReturnT</code> is incompatible with the current element_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMap</a> </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00206">206</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3959e42636ff0f847cf8e26bf2a079bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!detail::is_valid_element_value_type&lt;<a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T&gt;::value, T&gt; <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value data in the form of a specific type. </p>
<dl class="section note"><dt>Note</dt><dd>This overload requires a compatible value_get function overload. It is found via ADL.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The value type to be returned. Must be default constructible. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value represented by this <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> in the form of a <code>T</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When <code>ReturnT</code> is incompatible with the current element_type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>value_get </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00236">236</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4acd85d63ec845dfde47a8149ee025a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value from a <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a> compatible type. </p>
<p>Statically deduces element_type to closest match from <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a>. Forwards to value&lt;element_type&gt;(val).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When detected size differs from size of data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00255">255</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01844fe37dd9d3903035a9e87a2cbcd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value from a user-defined type. </p>
<p>Forwards to a user-supplied value_set function found by argument-dependent lookup (ADL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>value_set </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00274">274</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2d320e825fdf95ab8184fb412821480"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>new_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element_type, and value from a <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a> compatible type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_type</td><td>element_type of supplied value. </td></tr>
    <tr><td class="paramname">val</td><td>Value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Does not perform type deduction. Assumes <code>new_type</code> is correct type for <code>val</code>. </dd>
<dd>
Attempts to convert <code>val</code> to the type as determined by <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMapSet</a> and <code>new_type</code>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the size of the data differs from that detected. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When val's type is incompatible with <code>new_type</code>. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When type is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00305">305</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d40b400778dfdc44dc4aedab75461a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>new_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets element_type, and value from a user-defined type. </p>
<p>Forwards to a user-supplied value_set function found by argument-dependent lookup (ADL).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_type</td><td>element_type of supplied value. </td></tr>
    <tr><td class="paramname">val</td><td>Value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the size of the data differs from that detected. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>new_type</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00332">332</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acae6f793662cfcec1643708cbf394a40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;element_type EType, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_same&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">detail::ElementTypeMapSet</a>&lt; EType, <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &gt;&gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value. Statically ensures type compatibility. </p>
<p>Does not explicitly perform any type conversions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EType</td><td>element_type to set and check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the size of the data differs from that detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMapSet</a> detail::serialise() </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00374">374</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac4cd66241d3ee9b62bf85078e4e531e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container&gt; </div>
<div class="memtemplate">
template&lt;element_type EType, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::value </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_same&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42">detail::ElementTypeMapSet</a>&lt; EType, <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &gt;&gt;::value &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets value. Statically ensures type compatibility. </p>
<p>Performs conversion to type mapped from <a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMapSet</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EType</td><td>element_type to set and check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Strong exception guarantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the size of the data differs from that detected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#aed3af07e73bf2cf04ddebf7355547b42" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMapSet</a> detail::serialise() </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00411">411</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4091e9a5cd74f1fbb57de5c62871b50d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; std::is_void&lt; decltype(std::declval&lt; Visitor &gt;()(&quot;&quot;, std::declval&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;(), std::declval&lt; double &gt;()))&gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the visitor pattern with a void-return visitor. </p>
<p>Apply the visitor pattern on the element, based on its element_type.</p>
<p>Will pass the element's value, or nothing when the value type is void, to a supplied functor which returns <code>void</code>. This value is retrieved as if via <a class="el" href="namespacejbson.html#a810e5cdb5903f8282f1213b94f25cc29" title="Access element value of specific element_type. ">get()</a>, so the functor must accept all variations of: </p><div class="fragment"><div class="line">visitor(boost::string_ref, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>) <span class="comment">// for void types, e.g. element_type::null_element</span></div>
<div class="line">visitor(boost::string_ref, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>, detail::ElementTypeMap&lt;<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>&gt;) <span class="comment">// for all other element_type</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Functor that should accept multiple signatures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>type</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMap</a> </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00982">982</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af85de427b8084ac05d0a357ee26dd03b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename Visitor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!std::is_void&lt; decltype(std::declval&lt; Visitor &gt;()(&quot;&quot;, std::declval&lt; <a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a> &gt;(), std::declval&lt; double &gt;()))&gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; decltype(std::declval&lt;Visitor&gt;()(&quot;&quot;, std::declval&lt;<a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&gt;(), std::declval&lt;double&gt;()))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply the visitor pattern with a value-returning visitor. </p>
<p>Apply the visitor pattern on the element, based on its element_type.</p>
<p>Will pass the element's value, or nothing when the value type is void, to a supplied functor which returns some non-void type. This value is retrieved as if via <a class="el" href="namespacejbson.html#a810e5cdb5903f8282f1213b94f25cc29" title="Access element value of specific element_type. ">get()</a>, so the functor must accept all variations of: </p><div class="fragment"><div class="line">visitor(boost::string_ref, element_type) <span class="comment">// for void types, e.g. element_type::null_element</span></div>
<div class="line">visitor(boost::string_ref, element_type, detail::ElementTypeMap&lt;<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>&gt;) <span class="comment">// for all other element_type</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Functor that should accept multiple signatures. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>type</code> is invalid. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacejbson_1_1detail.html#a44faf9fbb1cb4a16db909040b15a05f2" title="Type alias to perform boost::mpl::at on TypeMap::map_type. ">detail::ElementTypeMap</a> </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l01006">1006</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb12e9d7291e3135117ec26b18fbaec7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::write_to_container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename container_type::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a BSON element without data, in-place into a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to write to. </td></tr>
    <tr><td class="paramname">it</td><td>Position in <code>c</code> to insert data. </td></tr>
    <tr><td class="paramname">name</td><td>Name of element. </td></tr>
    <tr><td class="paramname">type</td><td>Type of element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Basic exception guarantee.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When type is invalid </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When type is non-void, i.e. should contain data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00649">649</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada6f6a9947ab08a6dc4ca4e3ab66096e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::write_to_container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename container_type::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a type-deduced BSON element in-place into a container. </p>
<p>Accepts and performs type deduction only for types compatible with <a class="el" href="classjbson_1_1detail_1_1TypeMap.html" title="Compile-time map. Maps element_types to C++ type for serialisation/deserialisation. ">detail::TypeMap</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to write to. </td></tr>
    <tr><td class="paramname">it</td><td>Position in <code>c</code> to insert data. </td></tr>
    <tr><td class="paramname">name</td><td>Name of element. </td></tr>
    <tr><td class="paramname">val</td><td>Value of element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Basic exception guarantee. </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00562">562</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2633712f48994f2c326995cc4d500c38"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::write_to_container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename container_type::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt; detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a BSON element in-place, from compatible data, into a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to write to. </td></tr>
    <tr><td class="paramname">it</td><td>Position in <code>c</code> to insert data. </td></tr>
    <tr><td class="paramname">name</td><td>Name of element. </td></tr>
    <tr><td class="paramname">type</td><td>Type of element. </td></tr>
    <tr><td class="paramname">val</td><td>Value of element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Basic exception guarantee.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When type is invalid </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When type is void, i.e. should not contain data. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00594">594</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa573c7536e077d35d32743da19923037"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::write_to_container </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename container_type::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::string_ref&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">element_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::enable_if_t&lt;!detail::is_valid_element_set_type&lt; <a class="el" href="structjbson_1_1basic__element.html#aad57154ad9e7f7137e1be376ed2e76c4">container_type</a>, T &gt;::<a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a> &gt; *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a BSON element in-place, from incompatible data, into a container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Container to write to. </td></tr>
    <tr><td class="paramname">it</td><td>Position in <code>c</code> to insert data. </td></tr>
    <tr><td class="paramname">name</td><td>Name of element. </td></tr>
    <tr><td class="paramname">type</td><td>Type of element. </td></tr>
    <tr><td class="paramname">val</td><td>Value of element.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs a <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> to allow usage of value_set, and calls e.write_to_container(<code>c</code>, <code>it</code>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Basic exception guarantee.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When <code>type</code> is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1incompatible__type__conversion.html" title="Exception thrown when an element has a value not convertible to that requested. ">incompatible_type_conversion</a></td><td>When type is void, i.e. should not contain data. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the size of the data differs from that detected. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00630">630</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aad8025af3a29be37dc5c45da8c8d0762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
<div class="memtemplate">
template&lt;typename OutContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structjbson_1_1basic__element.html">jbson::basic_element</a>&lt; Container &gt;::write_to_container </td>
          <td>(</td>
          <td class="paramtype">OutContainer &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename OutContainer::const_iterator&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> to BSON data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Container to write to. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">it</td><td>Position in <code>c</code> to insert data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__type.html" title="Exception type thrown when an element has a type value not represented by element_type. ">invalid_element_type</a></td><td>When type of this <a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">basic_element</a> is invalid. </td></tr>
    <tr><td class="paramname"><a class="el" href="structjbson_1_1invalid__element__size.html" title="Exception thrown when an element&#39;s data size differs from that reported. ">invalid_element_size</a></td><td>When the detected size of the data differs from the actual size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Basic exception guarantee. </dd></dl>

<p>Definition at line <a class="el" href="element_8hpp_source.html#l00532">532</a> of file <a class="el" href="element_8hpp_source.html">element.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/chris/projects/jbson/include/jbson/<a class="el" href="element_8hpp_source.html">element.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    Copyright &copy; 2014 <a href="http://www.chrismanning.me.uk/">Christian Manning</a>. </br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
