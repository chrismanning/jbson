<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>jbson: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">jbson
   </div>
   <div id="projectbrief">C++11/1y BSON library</div>
  </td>
  <!-- github -->
  <a id="forkme_banner" href="https://github.com/chrismanning/jbson">View on GitHub</a>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">jbson Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#features">Features</a></li>
<li class="level1"><a href="#usage">Usage</a><ul><li class="level2"><a href="#elements">Elements</a></li>
<li class="level2"><a href="#building">Building Documents & Arrays</a></li>
<li class="level2"><a href="#docs">Documents</a></li>
<li class="level2"><a href="#doc_set">Document Set</a></li>
<li class="level2"><a href="#json">JSON Parsing</a></li>
</ul>
</li>
<li class="level1"><a href="#performance">Performance</a></li>
<li class="level1"><a href="#notes">Notes</a></li>
</ul>
</div>
<div class="textblock"><p>jbson is a library for building &amp; iterating BSON data, and JSON documents in C++14.</p>
<h1><a class="anchor" id="features"></a>
Features</h1>
<ul>
<li>Header only. Boost licensed.</li>
<li>Depends only on Boost headers &amp; C++14 standard library. <a href="#notes">note 3</a></li>
<li>Fully compatible with documented BSON specs.</li>
<li>A strict, iterator-based JSON parser. Mostly compliant with JSON standard. <a href="#notes">note 2</a></li>
<li>Parses <a href="http://docs.mongodb.org/manual/reference/mongodb-extended-json/">MongoDB extended JSON</a> from UTF-8,16,32 strings.</li>
<li>User-defined JSON literals <code>""_json_set</code>, <code>""_json_doc</code>, <code>""_json_arr</code>.</li>
<li>An implementation of <a href="http://goessner.net/articles/JsonPath/">JSONPath</a>, with some support for filtering with boolean expressions.</li>
</ul>
<h1><a class="anchor" id="usage"></a>
Usage</h1>
<p>All types and functions are under the <a class="el" href="namespacejbson.html">jbson</a> namespace.</p>
<h2><a class="anchor" id="elements"></a>
Elements</h2>
<p><code><a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">jbson::basic_element</a></code> is the class through which elements' names &amp; values are accessed and has a template parameter for its data container. Generally, this will be a non-owning range (e.g. <code>boost::iterator_range</code>), but there is an <code><a class="el" href="namespacejbson.html#ae2757fc80c35ebcc42429dc79dd1ad7a" title="Default basic_element type alias for owned BSON data. ">jbson::element</a></code> alias to <code><a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">jbson::basic_element</a>&lt;std::vector&lt;char&gt;&gt;</code> to enforce data ownership. The names are <em>always</em> copied (may change in the future). Value data may or may not be, depending on the container template parameter. The type of an element can be determined through comparison with the <code><a class="el" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7" title="The element_type enum represents a BSON data type. ">jbson::element_type</a></code> enum class values. Values can be accessed through the <code><a class="el" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f" title="Returns the value data in the form of a specific type. ">jbson::basic_element::value()</a></code> member function or the <code><a class="el" href="namespacejbson.html#a810e5cdb5903f8282f1213b94f25cc29" title="Access element value of specific element_type. ">jbson::get()</a></code> free function.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">jbson::element_type</a>;</div>
<div class="line"><a class="code" href="structjbson_1_1basic__element.html">jbson::element</a> elem;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keywordflow">if</span>(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::string_element) {</div>
<div class="line">    <span class="keyword">auto</span> str = elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>&lt;std::string&gt;();</div>
<div class="line">    <span class="comment">//OR</span></div>
<div class="line">    <span class="keyword">auto</span> str = jbson::get&lt;std::string&gt;(elem);</div>
<div class="line">    <span class="comment">//OR if container is contiguous</span></div>
<div class="line">    <span class="keyword">auto</span> str = elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>&lt;boost::string_ref&gt;();</div>
<div class="line">    <span class="comment">//OR</span></div>
<div class="line">    <span class="keyword">auto</span> str = jbson::get&lt;boost::string_ref&gt;(elem);</div>
<div class="line">    <span class="comment">//OR returns either std::string or boost::string_ref, depending on container</span></div>
<div class="line">    <span class="keyword">auto</span> str = jbson::get&lt;element_type::string_element&gt;(elem);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Elements can be modified using the <code>value()</code> member function.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7">jbson::element_type</a>;</div>
<div class="line"><a class="code" href="structjbson_1_1basic__element.html">jbson::element</a> elem;</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>(<span class="stringliteral">&quot;some string&quot;</span>);</div>
<div class="line">assert(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::string_element);</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>(123);</div>
<div class="line">assert(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::int32_element);</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>&lt;<span class="keywordtype">bool</span>&gt;(123);</div>
<div class="line">assert(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::boolean_element);</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>&lt;element_type::boolean_element&gt;(123);</div>
<div class="line">assert(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::boolean_element);</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#ada7fbb5d707f751fbc2db5ac5a8ca41f">value</a>(element_type::boolean_element, 123);</div>
<div class="line">assert(elem.<a class="code" href="structjbson_1_1basic__element.html#a9f8bbd80da1d125661d9e3bb11d83f8d">type</a>() == element_type::boolean_element);</div>
</div><!-- fragment --><p>Elements can also be accessed via the visitor pattern.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>jbson;</div>
<div class="line"><a class="code" href="structjbson_1_1basic__element.html">element</a> elem;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">struct </span>Visitor {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator()(boost::string_ref name, element_type etype, T&amp;&amp; value)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">// do something</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> operator()(boost::string_ref name, element_type etype)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="comment">// for elements whose type cannot have a value</span></div>
<div class="line">        <span class="comment">// e.g. null_element, undefined_element</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line">elem.<a class="code" href="structjbson_1_1basic__element.html#a4091e9a5cd74f1fbb57de5c62871b50d">visit</a>(Visitor{});</div>
</div><!-- fragment --><p>Visitors can also return values. It is not necessary to typedef a <code>return_type</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>jbson;</div>
<div class="line"><a class="code" href="structjbson_1_1basic__element.html">element</a> elem;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keyword">struct </span>IsNull {</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(boost::string_ref, element_type, T&amp;&amp;)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(boost::string_ref, element_type)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">bool</span> null = elem.<a class="code" href="structjbson_1_1basic__element.html#a4091e9a5cd74f1fbb57de5c62871b50d">visit</a>(IsNull{});</div>
</div><!-- fragment --><h2><a class="anchor" id="building"></a>
Building Documents &amp; Arrays</h2>
<p><code>builder</code> &amp; <code>array_builder</code> are simple classes used for building documents &amp; arrays, respectively. These allow for documents &amp; arrays to be built from variables, rather than just literals.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>jbson;</div>
<div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;str&quot;</span>s;</div>
<div class="line"><span class="keywordtype">int</span> num = 123;</div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//     &quot;some string&quot;: &quot;str&quot;,</span></div>
<div class="line"><span class="comment">//     &quot;some int&quot;: 123,</span></div>
<div class="line"><span class="comment">//     &quot;some obj&quot;: {</span></div>
<div class="line"><span class="comment">//         &quot;child bool&quot;: false</span></div>
<div class="line"><span class="comment">//     }</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="line"><a class="code" href="classjbson_1_1basic__document.html">document</a> doc = <a class="code" href="structjbson_1_1builder.html">builder</a></div>
<div class="line">    (<span class="stringliteral">&quot;some string&quot;</span>, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7a759e806af1addfe29a0752ed6c561673">element_type::string_element</a>, str)</div>
<div class="line">    (<span class="stringliteral">&quot;some int&quot;</span>, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7af456be2203f873a53e1fd04a912e0b09">element_type::int32_element</a>, num)</div>
<div class="line">    (<span class="stringliteral">&quot;some obj&quot;</span>, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7aeda37b150d88995ccb9af86cf6b5abf9">element_type::document_element</a>, <a class="code" href="structjbson_1_1builder.html">builder</a></div>
<div class="line">        (<span class="stringliteral">&quot;child bool&quot;</span>, <a class="code" href="namespacejbson.html#ad190198b7531d1c57e870c064b9f88f7aa9f390264c67240cb8f041539a2c303b">element_type::boolean_element</a>, <span class="keyword">false</span>)</div>
<div class="line">    );</div>
</div><!-- fragment --><p>While the intent of this is clear, it's a little verbose due to the explicit type. This can be omitted when the type is compatible with a JSON type. The above example becomes:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>jbson;</div>
<div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;str&quot;</span>s;</div>
<div class="line"><span class="keywordtype">int</span> num = 123;</div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//     &quot;some string&quot;: &quot;str&quot;,</span></div>
<div class="line"><span class="comment">//     &quot;some int&quot;: 123,</span></div>
<div class="line"><span class="comment">//     &quot;some obj&quot;: {</span></div>
<div class="line"><span class="comment">//         &quot;child bool&quot;: false</span></div>
<div class="line"><span class="comment">//     }</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="line"><a class="code" href="classjbson_1_1basic__document.html">document</a> doc = <a class="code" href="structjbson_1_1builder.html">builder</a></div>
<div class="line">    (<span class="stringliteral">&quot;some string&quot;</span>, str)</div>
<div class="line">    (<span class="stringliteral">&quot;some int&quot;</span>, num)</div>
<div class="line">    (<span class="stringliteral">&quot;some obj&quot;</span>, <a class="code" href="structjbson_1_1builder.html">builder</a></div>
<div class="line">        (<span class="stringliteral">&quot;child bool&quot;</span>, <span class="keyword">false</span>)</div>
<div class="line">    );</div>
</div><!-- fragment --><p>That's about as good as it's going to get. <code>array_builder</code> is used the same way, apart from the lack of a name parameter, which is an implicitly set integer.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>jbson;</div>
<div class="line"><span class="keyword">auto</span> str = <span class="stringliteral">&quot;str&quot;</span>s;</div>
<div class="line"><span class="keywordtype">int</span> num = 123;</div>
<div class="line"><span class="comment">// [&quot;str&quot;, 123, { &quot;child bool&quot;: false }]</span></div>
<div class="line"><a class="code" href="classjbson_1_1basic__array.html">array</a> arr = <a class="code" href="structjbson_1_1array__builder.html">array_builder</a></div>
<div class="line">    (str)</div>
<div class="line">    (num)</div>
<div class="line">    (<a class="code" href="structjbson_1_1builder.html">builder</a></div>
<div class="line">        (<span class="stringliteral">&quot;child bool&quot;</span>, <span class="keyword">false</span>)</div>
<div class="line">    );</div>
</div><!-- fragment --><h2><a class="anchor" id="docs"></a>
Documents</h2>
<p>The main classes of jbson are the templates <code><a class="el" href="classjbson_1_1basic__document.html" title="BSON document. ">jbson::basic_document</a></code>, <code><a class="el" href="classjbson_1_1basic__array.html" title="BSON array. ">jbson::basic_array</a></code> &amp; <code><a class="el" href="structjbson_1_1basic__element.html" title="BSON element. ">jbson::basic_element</a></code>. These types are parameterised with their underlying container or range. It's generally recommended to use a random-access range. Their default aliases i.e. <code>document</code> &amp; <code>element</code> are parameterised with <code>std::vector&lt;char&gt;</code>. The second template parameter of <code>basic_document</code> defines the parameter of child <code>basic_element</code>s. By default this is defined as a <code>boost::iterator_range</code> to avoid copying data, though care should be taken that this element does <b>not</b> outlive the container/document which owns the data, else it can be copied to its own <code><a class="el" href="namespacejbson.html#ae2757fc80c35ebcc42429dc79dd1ad7a" title="Default basic_element type alias for owned BSON data. ">jbson::element</a></code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classjbson_1_1basic__document.html">jbson::document</a> doc;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp;&amp; element: doc) {</div>
<div class="line">    <span class="comment">//...</span></div>
<div class="line">}</div>
<div class="line">std::for_each(doc.begin(), doc.end(), [](<span class="keyword">auto</span>&amp;&amp; v) { something(v); });</div>
</div><!-- fragment --><p><code>basic_array</code> is implemented using <code>basic_document</code> and the classes can usually be interchanged freely. Of course, <code>basic_document</code> is for documents and <code>basic_array</code> is for arrays and should be used as such.</p>
<p><code>basic_document</code> is simply a constant wrapper around its BSON data container, allowing iteration of elements in the form of a <code>basic_element</code>. It can be used with C++11's range-based for loop, and non-modifying standard algorithms. Iterators retain a copy of elements. This does not mean that an iterator contains a copy of an element's data, however.</p>
<h2><a class="anchor" id="doc_set"></a>
Document Set</h2>
<p><code>basic_document_set</code> is an alias template to <code>std::set&lt;basic_element,...&gt;</code> which <code>basic_document</code> and <code>basic_array</code> are explicitly convertible to. This can be used to easily modify an existing document, at the cost of copying/converting the entire document into its constituent elements. The type parameter of <code>basic_document_set</code> should be a <em>container</em> not a <em>range</em>, i.e. it should own the data. The default alias <code>document_set</code> is <code>basic_document_set&lt;std::vector&lt;char&gt;&gt;</code> making it a set of <code>basic_element&lt;std::vector&lt;char&gt;&gt;</code>.</p>
<div class="fragment"><div class="line"><a class="code" href="classjbson_1_1basic__document.html">jbson::document</a> doc;</div>
<div class="line"><span class="comment">//...</span></div>
<div class="line"><a class="code" href="namespacejbson.html#adb3b8bf9231a567d612df6110dfb92ed">jbson::document_set</a> set(doc);</div>
<div class="line"><span class="comment">//... modify set</span></div>
<div class="line">doc = set; <span class="comment">// convert back</span></div>
</div><!-- fragment --><h2><a class="anchor" id="json"></a>
JSON Parsing</h2>
<p>JSON documents can be parse with the <code>json_reader</code> class, which parses directly to BSON data and can be implicitly converted to any valid <code>basic_document</code>, <code>basic_array</code> or <code>basic_document_set</code>. It can also be move-converted to a <code>document</code> or <code>array</code> for efficient conversion.</p>
<div class="fragment"><div class="line"><a class="code" href="structjbson_1_1json__reader.html">jbson::json_reader</a> reader{};</div>
<div class="line">reader.parse(<span class="stringliteral">&quot;{\&quot;some json\&quot;: 123 }&quot;</span>);</div>
<div class="line">reader.parse(R<span class="stringliteral">&quot;({&quot;some json&quot;: 123 })&quot;); </span><span class="comment">// C++11 raw string</span></div>
<div class="line"><span class="keyword">auto</span> doc = <a class="code" href="namespacejbson.html#a3d7259346f8833a88b98d9767d4a4bd1">jbson::document</a>(std::move(reader));</div>
</div><!-- fragment --><p><code>json_reader</code> can parse string literals, or any range of UTF-(8, 16 or 32) characters e.g. <code>std::string</code>, <code>boost::string_ref</code>, <code>boost::iterator_range&lt;...&gt;</code>, <code>QByteArray</code>, etc. To parse UTF-16 or UTF-32 documents, <code>json_reader</code> must be passed a range of (or iterators to) <code>char16_t</code> or <code>char32_t</code>, respectively. It is assumed the input code units use the system endian, and a BOM (byte-order mark) at the beginning of input is an error. <code>json_reader</code> may also work with <code>wchar_t</code>, though this usage is non-standard, non-portable and unsupported. For convenience, user-defined literals have been implemented for JSON documents.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> jbson::literal;</div>
<div class="line"><span class="keyword">auto</span> doc = R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">    &quot;some json&quot;: 123</span></div>
<div class="line"><span class="stringliteral">})&quot;_json_doc;</span></div>
</div><!-- fragment --><p>This is equivalent to the above example.</p>
<h1><a class="anchor" id="performance"></a>
Performance</h1>
<p>Performance of the JSON parser is decent, as measured by <a href="https://github.com/mloskot/json_benchmark">json_benchmark</a>, it's 2nd only to rapidjson (or 3rd to QJsonDocument with small input):</p>
<blockquote class="doxtable">
<p>QJsonDocument.small: 1000 iterations of 500 parsings in 1.04621 to 1.05643 sec based on 2 benchmarks QJsonDocument.large: 1000 iterations of 1 parsings in 58.1027 to 58.1235 sec based on 2 benchmarks </p>
</blockquote>
<blockquote class="doxtable">
<p>jsoncpp.small: 1000 iterations of 500 parsings in 2.4124 to 2.45696 sec based on 2 benchmarks jsoncpp.large: 1000 iterations of 1 parsings in 62.7781 to 62.7823 sec based on 2 benchmarks </p>
</blockquote>
<blockquote class="doxtable">
<p>rapidjson.small: 1000 iterations of 500 parsings in 0.454047 to 0.48559 sec based on 2 benchmarks rapidjson.large: 1000 iterations of 1 parsings in 4.8566 to 4.86322 sec based on 2 benchmarks </p>
</blockquote>
<blockquote class="doxtable">
<p>jbson.small: 1000 iterations of 500 parsings in 1.24328 to 1.27775 sec based on 2 benchmarks jbson.large: 1000 iterations of 1 parsings in 43.0072 to 43.0377 sec based on 2 benchmarks </p>
</blockquote>
<blockquote class="doxtable">
<p>jsoncons.small: 1000 iterations of 500 parsings in 10.2386 to 10.2747 sec based on 2 benchmarks jsoncons.large: 1000 iterations of 1 parsings in 243.634 to 243.796 sec based on 2 benchmarks </p>
</blockquote>
<p>Some more measurements using <a href="https://github.com/sanSS/json-bechmarks">https://github.com/sanSS/json-bechmarks</a>.</p>
<h2>Small Objects</h2>
<table class="doxtable">
<tr>
<th>Parser </th><th>Average Time (us) </th><th>Memory Usage  </th></tr>
<tr>
<td>jsoncpp </td><td>9411 </td><td>4,084 K </td></tr>
<tr>
<td>QJsonDocument </td><td>7009 </td><td>3,684 K </td></tr>
<tr>
<td>jbson </td><td>5981 </td><td>1,132 K </td></tr>
</table>
<h2>Medium Objects</h2>
<table class="doxtable">
<tr>
<th>Parser </th><th>Average Time (us) </th><th>Memory Usage  </th></tr>
<tr>
<td>jsoncpp </td><td>121035 </td><td>44,224 K </td></tr>
<tr>
<td>QJsonDocument </td><td>82839 </td><td>37,996 K </td></tr>
<tr>
<td>jbson </td><td>64800 </td><td>24,708 K </td></tr>
</table>
<h2>Large Objects</h2>
<table class="doxtable">
<tr>
<th>Parser </th><th>Average Time (us) </th><th>Memory Usage  </th></tr>
<tr>
<td>jsoncpp </td><td>438745 </td><td>131,204 K </td></tr>
<tr>
<td>QJsonDocument </td><td>DNF </td><td>N/A </td></tr>
<tr>
<td>jbson </td><td>190883 </td><td>70,7748 K </td></tr>
</table>
<h1><a class="anchor" id="notes"></a>
Notes</h1>
<ol type="1">
<li>jbson uses BSON-like terminology. Eg. a document is not only the root object, but also all embedded objects.</li>
<li>BSON is incompatible with JSON in that element names cannot contain '\0', making names not fully UTF-8 compliant, which JSON requires.</li>
<li>Requires codecvt header (C++11, missing in gcc-4.8 &amp; gcc-4.9 stdlib), various template aliases (C++14), probably more where gcc's stdlib is behind on the standard. Known only to work with an up-to-date libc++ currently. </li>
</ol>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
    Copyright &copy; 2014 <a href="http://www.chrismanning.me.uk/">Christian Manning</a>. </br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
