{"name":"jbson","tagline":"JSON & BSON parser/writer","body":"jbson is a library for building & iterating BSON data, and JSON documents in C++14.\r\n\r\n## Features\r\n* UTF-8 support only (currently).\r\n* Header only.\r\n* Depends only on Boost headers & C++14 standard library. [note](#notes)\r\n* Fully compatible with documented BSON specs.\r\n* A strict, iterator-based JSON parser. Mostly compliant with JSON standard. [note](#notes)\r\n* Parses [MongoDB extended JSON](http://docs.mongodb.org/manual/reference/mongodb-extended-json/).\r\n* User-defined JSON literals `\"\"_json_set`, `\"\"_json_doc`, `\"\"_json_arr`.\r\n* An implementation of [JSONPath](http://goessner.net/articles/JsonPath/), with some support for filtering with boolean expressions.\r\n\r\n## Usage\r\n\r\nAll types are under the `jbson` namespace.\r\n\r\n### Documents\r\n\r\nThe main classes of jbson are the templates `basic_document`, `basic_array` & `basic_element`. These types are parameterised with their underlying container or range. It's generally recommended to use a random-access range. Their default aliases i.e. `document` & `element` are parameterised with `std::vector<char>`. The second template parameter of `basic_document` defines the parameter of child `basic_element`s. By default this is defined as a `boost::iterator_range` to avoid copying data, though care should be taken that this element does **not** outlive the container/document which owns the data, else it can be copied to its own element.\r\n```C++\r\n{\r\n    jbson::document doc;\r\n    ...\r\n    for(auto&& element: doc) {\r\n        ...\r\n    }\r\n    std::for_each(doc.begin(), doc.end(), [](auto&& v) { something(v); });\r\n}\r\n```\r\n`basic_array` is implemented using `basic_document` and the classes can usually be interchanged freely. Of course, `basic_document` is for documents and `basic_array` is for arrays and should be used as such.\r\n\r\n`basic_document` is simply a constant wrapper around its BSON data container, allowing iteration of elements in the form of a `basic_element`. It can be used with C++11s range-based for loop, and non-modifying standard algorithms.  \r\nIterators retain a copy of elements. This does not mean that an iterator contains a copy of an element's data, however.\r\n\r\n### Document Set\r\n\r\n`basic_document_set` is an alias template to `std::multi_set<basic_element,...>` which `basic_document` and `basic_array` is explicitly convertible to. This can be used to modify an existing document, at the cost of copying/converting the entire document into its constituent elements. The type parameter of `basic_document_set` should be a *container* not a *range*, i.e. it should own the data. The default alias `document_set` is `basic_document_set<std::vector<char>>` making it a set of `basic_element<std::vector<char>>`.\r\n```C++\r\n{\r\n    jbson::document doc;\r\n    ...\r\n    jbson::document_set set(doc);\r\n    ... modify set\r\n    doc = set; // convert back\r\n}\r\n```\r\n\r\n### Elements\r\n\r\n`basic_element` is the class through which elements' names & values are accessed. The names are *always* copied (may change in the future). Value data may or may not be, depending on the container template parameter.  \r\nThe type of an element can be determined through comparison with the `element_type` enum class values.  \r\nValues can be accessed through the `value()` member function or the `get()` free function.\r\n```C++\r\n{\r\n    using jbson::element_type;\r\n    jbson::element elem;\r\n    ...\r\n    if(elem.type() == element_type::string_element) {\r\n        auto str = elem.value<std::string>();\r\n        //OR\r\n        auto str = jbson::get<std::string>(elem);\r\n        //OR if container is contiguous\r\n        auto str = elem.value<boost::string_ref>();\r\n        //OR\r\n        auto str = jbson::get<boost::string_ref>(elem);\r\n        //OR returns either std::string or boost::string_ref, depending on container\r\n        auto str = jbson::get<element_type::string_element>(elem);\r\n    }\r\n}\r\n```\r\nElements can be modified using the `value()` member function.\r\n```C++\r\n{\r\n    using jbson::element_type;\r\n    jbson::element elem;\r\n    elem.value(\"some string\");\r\n    assert(elem.type() == element_type::string_element);\r\n    elem.value(123);\r\n    assert(elem.type() == element_type::int32_element);\r\n    elem.value<bool>(123);\r\n    assert(elem.type() == element_type::boolean_element);\r\n    elem.value<element_type::boolean_element>(123);\r\n    assert(elem.type() == element_type::boolean_element);\r\n    elem.value(element_type::boolean_element, 123);\r\n    assert(elem.type() == element_type::boolean_element);\r\n}\r\n```\r\nElements can also be accessed via the visitor pattern.\r\n```C++\r\n{\r\n}\r\n```\r\n\r\n### JSON Parsing\r\n\r\nJSON documents can be parse with the `json_reader` class, which parses directly to BSON data and can be implicitly converted to any valid `basic_document`, `basic_array` or `basic_document_set`. It can also be move-converted to a `document` or `array` for efficient conversion.\r\n```C++\r\n{\r\n    jbson::json_reader reader{};\r\n    reader.parse(\"{\\\"some json\\\": 123 }\");\r\n    reader.parse(R\"({\"some json\": 123 })\"); // C++11 raw string\r\n    auto doc = jbson::document(std::move(reader));\r\n}\r\n```\r\n`json_reader` can parse string literals, or any range of UTF-8 codepoints e.g. `std::string`, `boost::string_ref`, `boost::iterator_range<...>`, `QByteArray`, etc.  \r\nFor convenience, user-defined literals have been implemented for JSON documents.\r\n```C++\r\n{\r\n    using jbson::literal;\r\n    auto doc = R\"({\r\n        \"some json\": 123\r\n    })\"_json_doc;\r\n}\r\n```\r\nThis is equivalent to the above example.\r\n\r\n## Performance\r\nPerformance of the JSON parser is decent, as measured by [json_benchmark](https://github.com/mloskot/json_benchmark), it's 2nd only to rapidjson:\r\n\r\n> QJsonDocument.small: 1000 iterations of 500 parsings in 8.36422 to 8.36658 sec based on 2 benchmarks  \r\n> QJsonDocument.large: 1000 iterations of 1 parsings in 311.287 to 311.843 sec based on 2 benchmarks\r\n\r\n> jsoncpp.small: 1000 iterations of 500 parsings in 13.7716 to 13.782 sec based on 2 benchmarks  \r\n> jsoncpp.large: 1000 iterations of 1 parsings in 283.477 to 284.996 sec based on 2 benchmarks\r\n\r\n> rapidjson.small: 1000 iterations of 500 parsings in 0.99631 to 1.00371 sec based on 2 benchmarks  \r\n> rapidjson.large: 1000 iterations of 1 parsings in 13.4129 to 13.4314 sec based on 2 benchmarks\r\n\r\n> jbson.small: 1000 iterations of 500 parsings in 4.88315 to 4.89001 sec based on 2 benchmarks  \r\n> jbson.large: 1000 iterations of 1 parsings in 131.038 to 131.099 sec based on 2 benchmarks\r\n\r\n> jsoncons.small: 1000 iterations of 500 parsings in 10.8905 to 10.9053 sec based on 2 benchmarks  \r\n> jsoncons.large: 1000 iterations of 1 parsings in 551.351 to 552.098 sec based on 2 benchmarks\r\n\r\n## Notes\r\n\r\njbson uses BSON-like terminology. Eg. a document is not only the root object, but also all embedded objects.\r\n\r\nBSON is incompatible with JSON in that element names cannot contain `'\\0'`, making names not fully UTF-8 compliant, which JSON requires.\r\n\r\nRequires `<codecvt>` header (C++11, missing in gcc-4.8's stdlib), various template aliases (C++14), probably more where gcc's stdlib is behind on the standard.  \r\nKnown only to work with an up-to-date libc++ currently.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}